<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on Facile.it Engineering</title>
    <link>https://engineering.facile.it/categories/swift/</link>
    <description>Recent content in Swift on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Mar 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://engineering.facile.it/categories/swift/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Decoupling view controllers with Signals</title>
      <link>https://engineering.facile.it/blog/eng/decoupling-view-controllers-with.signals/</link>
      <pubDate>Tue, 15 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/decoupling-view-controllers-with.signals/</guid>
      <description>Last time we looked at the Signal class, that is, a simple, reusable way of encapsulating the observer pattern. There are many use cases for a signal, and I&amp;rsquo;m going to show one possible application, spawned from a real-world problem. View controllers&amp;rsquo; composition and decoupling is hard: we often need an input from a view controller, that has to send its input back to its creator, while handling the back navigation somehow.</description>
    </item>
    
    <item>
      <title>Code reuse: a primer</title>
      <link>https://engineering.facile.it/blog/eng/code-reuse-a-primer/</link>
      <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/code-reuse-a-primer/</guid>
      <description>Last time we looked at a possible implementation for the Optional type in Objective-C; while the main point was to port to Objective-C a tool that&amp;rsquo;s frequently used in Swift, making use of the Optional class can be considered an application of a much more general concept: code reuse. In fact, Optional is not tied to a particular domain, and can be reused over and over again in multiple projects: that&amp;rsquo;s what actually happens in Swift.</description>
    </item>
    
    <item>
      <title>Codice riusabile: un primer</title>
      <link>https://engineering.facile.it/blog/ita/codice-riusabile-un-primer/</link>
      <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/codice-riusabile-un-primer/</guid>
      <description>L&amp;rsquo;ultima volta abbiamo visto una possibile implementazione del tipo Optional in Objective-C; l&amp;rsquo;obiettivo primario dell&amp;rsquo;articolo era quello di importare in Objective-C uno strumento frequentemente utilizzato in Swift, ma usare una classe come Optional può essere considerato un&amp;rsquo;applicazione di un concetto molto più generale: il riutilizzo del codice. In effetti, Optional non è legato a un particolare dominio, e può essere riutilizzato più e più volte in molti progetti: questo è esattamente ciò che accade in Swift.</description>
    </item>
    
    <item>
      <title>Optionals in Objective-C</title>
      <link>https://engineering.facile.it/blog/eng/optionals-in-objective-c/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/optionals-in-objective-c/</guid>
      <description>Objective-C is not going anywhere. While Swift is most certainly the new hotness for iOS and OS X programming, there are some concrete reasons to stick with Objective-C for a while:
 Objective-C based projects still need maintenance and new features to be added, and mixing Swift and Objective-C, while possible, can be tricky and possibly unconvenient, due to the dynamic nature of the latter; Swift is changing rapidly, has still some bugs and performance problems, and still lacks some features that professionals need, while Objective-C is mature and has a strong community; some may prefer a more dynamic language, and Objective-C support from Apple is still strong;  Personally, while I naturally lean towards a more static, type-first approach to programming, from time to time I like to work in a more dynamic environment, so both for preference and for business needs, I still didn&amp;rsquo;t put Objective-C completely away.</description>
    </item>
    
    <item>
      <title>Optionals in Objective-C</title>
      <link>https://engineering.facile.it/blog/ita/optionals-in-objective-c/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/optionals-in-objective-c/</guid>
      <description>Objective-C vivrà ancora per molto. Nonostante Swift sia il nuovo punto di riferimento per lo sviluppo iOS e OS X, ci sono ragioni concrete per scegliere di continuare a sviluppare in Objective-C, almeno per un po&amp;rsquo;:
 progetti esistenti basati su Objective-C richiedono ancora mantenimento e probabile aggiunta di nuove funzionalità, e anche se è tecnicamente possibile mescolare i linguaggi, la cosa può risultare poco conveniente per via della natura molto dinamica di Objective-C; Swift sta cambiando rapidamente, presenta ancora alcuni bug e problemi di performance, e il suo workflow manca ancora di alcune feature fondamentali per i professionisti, mentre Objective-C è un linguaggio maturo, con una community molto vivace; alcuni possono preferire un linguaggio più dinamico, e il supporto di Apple su Objective-C è ancora forte;  Personalmente ho la tendenza a preferire linguaggi più statici, e un approccio type-first alla programmazione, ma di tanto in tanto mi piace lavorare in un ambiente più dinamico, quindi, sia per preferenza personale che per esigenze di business, non ho ancora messo Objective-C da parte.</description>
    </item>
    
    <item>
      <title>Swift testing avanzato: stubbing e test asincroni</title>
      <link>https://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</link>
      <pubDate>Fri, 05 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</guid>
      <description>In un precedente articolo abbiamo visto le impostazioni di base in Xcode per la scrittura dei test unitari: abbiamo evidenziato inoltre l&amp;rsquo;importanza e l&amp;rsquo;utilità intrinseca dei test, attraverso un semplice esempio riguardante un caso d&amp;rsquo;uso tipico. Nel presente articolo vedremo alcune tecniche un po&amp;rsquo; più avanzate:
 implementeremo uno Stub Object in Swift; analizzeremo un altro caso di test asincrono;  Lo Stub Object Uno Stub Object (per il resto dell&amp;rsquo;articolo, stub) rappresenta un&amp;rsquo;istanza di una certa classe, la quale mima una vera classe presente nella nostra code base: l&amp;rsquo;istanza si comporta esattamente come una equivalente istanza della classe mimata, tranne alcune differenze, ad esempio alcuni metodi possono essere sovrascritti per poter fornire un determinato output utile per i test.</description>
    </item>
    
    <item>
      <title>Type First Development in Swift</title>
      <link>https://engineering.facile.it/blog/ita/type-first-development-in-swift/</link>
      <pubDate>Tue, 05 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/type-first-development-in-swift/</guid>
      <description>Con Type First Development può intendersi un approccio allo sviluppo di nuove funzionalità o moduli di un software partendo dai tipi di dati coinvolti: non si tratta quindi di un pattern o una pratica codificata, ma solo di un possibile punto di partenza per iniziare il ragionamento. Ragionando esclusivamente sui tipi, prima ancora di pensare alle singole specifiche implementazioni dei vari blocchi di codice, è possibile costruire più facilmente una mappa dei vari di flussi di dati che attraversano il nostro software, e verificare immediatamente se stiamo scrivendo qualcosa di sensato, solido ed adeguatamente estendibile.</description>
    </item>
    
    <item>
      <title>Xcode Testing in pratica</title>
      <link>https://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</link>
      <pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</guid>
      <description>Tra i molti strumenti utili presenti in Xcode, il testing framework XCTest è certamente uno dei più rilevanti, non solo per l&amp;rsquo;importanza intrinseca dello Unit Testing in generale, ma soprattutto per la facilità con la quale è possibile scrivere ed eseguire test direttamente dall&amp;rsquo;IDE out-of-the-box, senza la necessità di installare componenti di terze parti o impostare una particolare configurazione per i progetti.
In effetti Xcode, al momento della creazione di un nuovo progetto, oltre a creare un target per il binario principale crea automaticamente anche un target di test, cioè un bundle aggiuntivo che può essere caricato nel bundle principale per poter fisicamente eseguire i test una volta avviata l&amp;rsquo;app.</description>
    </item>
    
  </channel>
</rss>