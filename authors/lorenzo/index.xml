<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lorenzo on Facile.it Engineering</title>
    <link>https://engineering.facile.it/authors/lorenzo/</link>
    <description>Recent content in lorenzo on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 11 Jan 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://engineering.facile.it/authors/lorenzo/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Write a filesystem with FUSE</title>
      <link>https://engineering.facile.it/blog/eng/write-filesystem-fuse/</link>
      <pubDate>Mon, 11 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/write-filesystem-fuse/</guid>
      <description>During the past year I experimented a lot with file systems in Userspace using FUSE, I wrote this post to share my thoughts about what I did and to give you a starting point to do something by yourself.
Introduction A filesystem is that piece of software that is in charge of storing, organizing and generally taking care of data represented as files and directories. If you are using a device to read this post you are probably using at least one filesystem at the moment.</description>
    </item>
    
    <item>
      <title>Da sviluppo a produzione con Docker e AWS Elastic Beanstalk</title>
      <link>https://engineering.facile.it/blog/ita/da-sviluppo-a-produzione-con-docker-e-aws-elastic-beanstalk/</link>
      <pubDate>Mon, 19 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/da-sviluppo-a-produzione-con-docker-e-aws-elastic-beanstalk/</guid>
      <description>In locale funzionava Questo articolo si rivolge a chi ha già una conoscenza base di docker e del suo funzionamento e sta cercando come avanzare al passo successivo, usandolo quotidianamente in sviluppo e in produzione.
Avere un ambiente di sviluppo/test il più simile possibile a quello di produzione aiuta molto nel garantire un corretto funzionamento dopo il deploy.
In uno scenario tipico, lo sviluppatore ha installati sulla propria macchina locale tutti i servizi da cui dipende la sua applicazione, il che comporta quanto segue:</description>
    </item>
    
    <item>
      <title>From development to production with Docker and AWS Elastic Beanstalk</title>
      <link>https://engineering.facile.it/blog/eng/from-development-to-production-with-docker-and-amazon-ecs/</link>
      <pubDate>Mon, 19 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/from-development-to-production-with-docker-and-amazon-ecs/</guid>
      <description>It works on my machine This post is addressed to people who already have basic knowledge about docker, about how it works and are looking for a way to move to the next step with the goal of using it in development and production day by day.
Having a development/testing environment as close as possible to the production one helps a lot in assuring that things will behave correctly when delivered.</description>
    </item>
    
    <item>
      <title>PHP 7 Overview</title>
      <link>https://engineering.facile.it/blog/ita/php-7-overview/</link>
      <pubDate>Mon, 06 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/php-7-overview/</guid>
      <description>Il linguaggio che ha contribuito alla nascita e alla crescita di più del 80% dei siti web oggi online, tra i quali alcuni dei più famosi al mondo, è prossimo a una svolta.
Secondo la timeline ufficiale PHP 7 sarà rilasciato intorno al 15 Ottobre 2015: chi volesse provarlo in anteprima, tuttavia, può trovare binari, rpm, deb, dockerfiles e quant&amp;rsquo;altro su php7.zend.com.
La release 7 costituisce una delle più importanti per PHP, sia in termini di funzionalità che di performance.</description>
    </item>
    
    <item>
      <title>Continuous Integration con Docker e Drone</title>
      <link>https://engineering.facile.it/blog/ita/continuos-integration-docker-drone/</link>
      <pubDate>Fri, 12 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/continuos-integration-docker-drone/</guid>
      <description>La continuous integration è una pratica che consiste nel frequente allineamento, su di una base comune definita mainline, delle copie di lavoro degli sviluppatori che collaborano al codice di un progetto.
Introdotta inizialmente da Grady Booch nel 1991, nella pubblicazione Object Oriented Design: With Applications, la pratica è stata estesa e sviluppata all&amp;rsquo;interno dell&amp;rsquo;extreme programming, fino a sostenere la necessità di allineare le copie di lavoro diverse volte al giorno.</description>
    </item>
    
    <item>
      <title>L&#39;operatore ternario è associativo a sinistra!</title>
      <link>https://engineering.facile.it/blog/ita/operatore-ternario-e-associativo-a-sinistra/</link>
      <pubDate>Mon, 02 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/operatore-ternario-e-associativo-a-sinistra/</guid>
      <description>Gli operatori ternari sono diffusi in molti linguaggi di programmazione e permettono di esprimire con una sintassi breve logiche condizionali. Per utilizzarli propriamente in PHP è però necessario conoscerne il comportamento.
Vediamo un esempio
var_dump(true ? &amp;#39;a&amp;#39; : &amp;#39;b&amp;#39; ? &amp;#39;c&amp;#39; : &amp;#39;d&amp;#39;); // OUTPUT: string(1) &amp;#34;c&amp;#34; Se state pensando che il risultato di questa espressione sia ovvio, vediamo cosa succede ad esempio in javascript
console.log(true ? &amp;#39;a&amp;#39; : &amp;#39;b&amp;#39; ?</description>
    </item>
    
    <item>
      <title>var_dump() aggiunge proprietà pubbliche a DateTime</title>
      <link>https://engineering.facile.it/blog/ita/var_dump-aggiunge-proprieta-pubbliche-a-datetime/</link>
      <pubDate>Mon, 02 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/var_dump-aggiunge-proprieta-pubbliche-a-datetime/</guid>
      <description>PHP, fin dalla versione 5.2.0, introduce gli oggetti \DateTime per operare con date ed intervalli, fornendo finalmente un alternativa alle vecchie funzioni procedurali.
Recentemente mi sono reso conto di uno strano comportamento che si verifica quando vengono chiamate var_dump, print_r, var_export o debug_zval_dump su un istanza di \DateTime.
Considerando il seguente codice e il suo output:
$date = new \DateTime(); var_dump(isset($date-&amp;gt;date)); // OUTPUT: bool(false) ci rendiamo conto del fatto che non esiste alcuna proprietà $date all&amp;rsquo;interno dell&amp;rsquo;istanza di \DateTime.</description>
    </item>
    
    <item>
      <title>ZVALs refcount AKA come vengono memorizzate le nostre variabili</title>
      <link>https://engineering.facile.it/blog/ita/zvals-refcount/</link>
      <pubDate>Mon, 02 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/zvals-refcount/</guid>
      <description>Assegnare valori alle variabili è sicuramente l&amp;rsquo;operazione più comune all&amp;rsquo;interno di uno script PHP. Ma come vengono conservate queste informazioni dall&amp;rsquo;interprete? Vediamolo assieme!
L&amp;rsquo;unità fondamentale di storage dei dati in PHP è la Zend Value (zval). Si tratta di una struct definita alla linea 334 di zend.h, la riporto qui di seguito per commentarne le proprietà.
struct _zval_struct { zvalue_value value;	/* Il valore assegnato alla variabile */ zend_uint refcount__gc; /* Il conto delle referenze legato alla variabile */ zend_uchar type;	/* L&#39;identificativo del tipo di dato */ zend_uchar is_ref__gc; /* Flag che indica se la variabile è o meno una referenza */ }; Il tipo di dato zvalue_value non è altro che una union contenente tutti i tipi di dato gestiti da php, per questo ogni variabile che instanziamo in PHP, sia essa un intero o una stringa occuperà comunque lo stesso spazio in memoria richiesto per il tipo di dato più grande.</description>
    </item>
    
  </channel>
</rss>